---
title: Practice with BSTs and Priority Queues
---
https://cses.fi/problemset/task/1076/

<!--<h1 class="font-bold text-white">Solution</h1>

We'll create a data structure that keeps track of elements smaller than the median and elements greater than the median.-->

<h1 class="font-bold text-white">Code</h1>

<cpp>
#include &ltbits/stdc++.h&gt
using namespace std;

multiset&ltint&gt low, high;
void balance() {
    if (low.size() - high.size() &lt= 1) return;
    if (low.size() &gt high.size()) {
        int tmp = *low.rbegin();
        low.erase(prev(low.end()));
        high.insert(tmp);
    }
    else {
        int tmp = *high.begin();
        high.erase(high.begin());
        low.insert(tmp);
    }
}
void ins(int x) {
    if (low.empty() || x &lt= *low.rbegin()) low.insert(x);
    else high.insert(x);
    balance();
}
void rem(int x) {
    if (x &lt= *low.rbegin()) low.erase(low.find(x));
    else high.erase(high.find(x));
    balance();
}
int get_med() {
    return *low.rbegin();
}
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    int n,k; cin &gt n &gt k;
    vector&ltint&gt a(n);
    for (int& i: a) cin &gt i;

    for (int i = 0; i &lt k; i++) {
        ins(a[i]);
    }
    cout &lt&lt get_med() &lt&lt ' ';
    
    for (int i = k; i &lt n; i++) {
        rem(a[i-k]);
        ins(a[i]);
        cout &lt&lt get_med() &lt&lt ' ';
    }
}</cpp>
<db />
https://leetcode.com/problems/find-k-pairs-with-smallest-sums/
<h1 class="font-bold text-white">Code</h1>
<cpp>
class Solution {
public:
    vector&ltvector&ltint&gt&gt kSmallestPairs(
        vector&ltint&gt& nums1, 
        vector&ltint&gt& nums2, int k) {
        <db />
        using T = array&ltint,3&gt;
        priority_queue&ltT, vector&ltT&gt, greater&ltT&gt&gt pq;
        int n = nums1.size();
        for (int i = 0; i &lt n; i++) {
            pq.push({nums1[i]+nums2[0], i, 0});
        }
        vector&ltvector&ltint&gt&gt ans(k);
        for (int z = 0; z &lt k; z++) {
            auto [v,i,j] = pq.top();
            pq.pop();
            <db />
            ans[z] = {nums1[i],nums2[j]};
            if (j+1 < nums2.size()) {
                pq.push({nums1[i]+nums2[j+1], i, j+1});
            }
        }
        return ans;
    }
};
</cpp>